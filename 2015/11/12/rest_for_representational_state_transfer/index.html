<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>REST for Representational State Transfer</title> <meta name="description" content="This small article aims at giving a concise idea of what is the essence of a RESTful API andhow to build a stateless one. Incidentally, stateless RESTful API..."> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="http://ktorz.github.io/2015/11/12/rest_for_representational_state_transfer/"> <link rel="alternate" type="application/rss+xml" title="KtorZ's Blog" href="http://ktorz.github.io/feed.xml"> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> <link rel="alternate" type="application/atom+xml" title="" href="http://ktorz.github.io/feed.xml" /> <script src="/assets/js/modernizr.js"></script> <!-- Google Analytics --> </head> <body"> <main class="wrapper"> <header class="site-header"> <a href="#navbar" id="menu-burger" class="menu-burger">Menu <span class="nav-icon"></span> <svg x="0px" y="0px" width="54px" height="54px" viewBox="0 0 54 54"> <circle fill="transparent" stroke="#000000" stroke-width="1" cx="27" cy="27" r="25" stroke-dasharray="157 157" stroke-dashoffset="157"></circle> </svg> </a> <div id="navbar" class="navbar"> <div class="navigation-wrapper"> <div class="half-block"> <h2>Navigation</h2> <nav> <ul class="primary-nav"> <li><a href="/">Blog</a></li> <li><a href="/references">References</a></li> <li><a href="/about">About</a></li> <li><a href="http://github.com/KtorZ" target="_blank"><i class="icon icon-github"></i> Github</a></li> <li><a href="http://linkedin.com/in/matthias-benkort-47186a57" target="_blank"><i class="icon icon-linkedin"></i> LinkedIn</a></li> <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> RSS</a></li> </ul> </nav> </div> </div> </div> </header> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header intro"> <div class="intro-in"> <h1 class="post-title" itemprop="name headline">REST for Representational State Transfer</h1> <p class="post-meta"><time datetime="2015-11-12T18:08:57+01:00" itemprop="datePublished">Nov 12, 2015</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Matthias Benkort</span></span></p> </div> </header> <div class="post-content container" itemprop="articleBody"> <p>This small article aims at giving a concise idea of what is the essence of a RESTful API and how to build a stateless one. Incidentally, stateless RESTful API now appears to me as a tautology: a RESTful API is stateless <strong>by nature</strong>.</p> <p>Even the name would suggest that: <em>state transfer</em> meaning that REST gives a way of representing exchanges between a provider and a client where states are included within that transfer. In other words, this means that the client <strong>should</strong> take care of any state that exists (such as a session after an authentication) and has to communicate the necessary pieces of information during API calls. That’s why HTTP headers stand for, and this is what I’ll try to hereby put forward.</p> <!--more--> <h2 id="pre-requisite">Pre-requisite</h2> <p>First of all, we assume that any communication between the server and the client are done through SSL using HTTPS. Thereby, communications are protected against man-in-middle attack and we can assume that information coming from a client are really coming from a trusty client.</p> <p>Also, in order to authenticate, client will have to provide credentials on a given endpoint. None of those credentials are directly stored in the database. The server would rather store a hash using a SHA-256 algorithm and a salt, also stored alongside the password. As a matter of fact no compromising and valuable information should be stored as is in the server. Encryption algorithms allow a one-way encryption.</p> <h2 id="the-secret-key">The secret key</h2> <p>In order to be stateless, the server has to provide an API that is idempotent and that does not rely on any kind of session or cookie mechanism. There is no idea of session on the server. The only thing that is stored is a given secret key known <strong>only</strong> by the server itself. That key is a single point of failure meaning that anyone who owns it would be able to replicate the behavior of the server. However, the only way to get that key is by having direct access on the server. In such a case, we’re in any scenario completely screwed. Also, The server should be able to renew this secret key periodically. The previous key has to be kept in memory until it becomes useless (after a delay greater than the expiration delay of the last created token; we’ll come to that in a second). This way, attackers trying to identify or guess the secret key would be short-circuited.</p> <p>We assume now that the server is holding a secret key which is at least <code>16 bytes</code> long and base64 encoded (just a matter of choice, arbitrary)</p> <h2 id="free-endpoints">Free endpoints</h2> <p>Some endpoints of the application might be accessible for anyone. For instance, an application could provide the weather to any user willing to retrieve this piece of information. In such a case, there is no need to check the trustyness of a given client. One’s making a request on a given url, one’s getting the corresponding response. This is straightforward and is completely stateless.</p> <h2 id="restricted-endpoints">Restricted endpoints</h2> <p>The interesting part shows when one deals with restricted endpoints; those that need to be protected with an authentication process. The main idea emerging with oAuth and oAuth2 is to give the client a way to present himself as a valid authenticated user. A request to an authentication endpoint should in exchange of valid credentials returns an encoded token. That token should be different for any request and should expire after a given delay (one week, one day, one month…).</p> <p>There are two strategies to communicate a token to the user. The former is what is basically done with oAuth2 and the latter echoes standards such as <em>JWT</em>. In both cases, what is given to the client is nothing more than an expiration date and a user or session id in such a way that the server will know they are valid.</p> <h3 id="plain-json-response">Plain JSON response</h3> <p>The first strategy consist in returning a plain JSON object defining three attributes:</p> <ul> <li><code>uid</code></li> <li><code>expiration_date</code></li> <li><code>token</code></li> </ul> <p>The <code>uid</code> and the <code>expiration_date</code> are used to describe the authentication. They give a validity period and the user id who’s initiated the authentication. The <code>token</code> is an encoded string composed of that <code>uid</code> and <code>expiration_date</code> such as:</p><pre><code>token = hmac256(uid|expiration_date, secret_key)
</code></pre><p>That way, when the client needs to request some data from the server, he has to supply the three pieces of information above. Using those data, the server would try to recover the token from the <code>uid</code> and the <code>expiration_date</code>. If the computed result matches the given <code>token</code>, then we can assume that the authentication information is valid.</p> <p>In other words, the server is encoding the token using a one-way encryption algorithm (MAC/Hashed key) with a secret key. It holds that secret key but gives the client the public informations and the result of the encryption.</p> <h3 id="encryption-and-decryption">Encryption and Decryption</h3> <p>Another strategy would be to use a “two-ways” encryption algorithm (a cipher) such as AES, meaning that the server will be able to encrypt a given data but also to decrypt the encoded result to get back the data. In that way, the server can only provide a single encrypted token with an equivalent form as before:</p><pre><code>token = AES256(uid|expiration_date, secret_key)
</code></pre><p>The client would have to send the token through each request. Receiving the request, the server would try to decrypt the token and retrieve both the <code>uid</code> and the <code>expiration_date</code>. Also, it is recommended to associate the token to routes that are indeed refering to the user (either as a route identifier or as a concrete parameter of the request). Thereby, the server can check if the token is matching the given user and prevent attacker from trying to send fake request with a randomly generated token even if the chance of generating a random valid token is more than insignifiant.</p> <h3 id="which-one">Which one?</h3> <p>Both strategies are equivalent to me. However, the second one allows the client to transfer only one piece of information which could seemly be placed in the <code>Authorization</code> HTTP header. Furthermore, this makes sense as this header was initially dedicated to that purpose.</p> <h2 id="conclusion">Conclusion</h2> <p>Having a RESTful API requires some constraints and standards to adopt. Also, the token’s management is under the client responsability, meaning that if the client isn’t secure then the app is compromised. Though, this isn’t inherent to that protocol. It would be the same with any kind of authentication. This way of authentication and architecture gives nevertheless the opportunity to build a completely stateless RESTful API - awesome.</p> <h2 id="references">References</h2> <ul> <li><a href="https://en.wikipedia.org/wiki/HTTP_cookie#Drawbacks_of_cookies">Drawbacks of Cookies</a></li> <li><a href="https://www.owasp.org/index.php/Guide_to_Authentication">OWASP Guide to Authentication</a></li> <li><a href="http://aaronparecki.com/articles/2012/07/29/1/oauth2-simplified">OAuth2 Simplified</a></li> <li><a href="http://stackoverflow.com/questions/549/the-definitive-guide-to-form-based-website-authentication">SO: The Definitive Guide to Form Based Website Authentication</a></li> <li><a href="http://blog.romainpellerin.eu/designing-an-efficient-rest-api.html">Designing an Efficient Rest API</a></li> <li><a href="http://restcookbook.com/Basics/loggingin/">The Restful CookBook</a></li> <li><a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">Best Practices for Designing a Pragmatic RESTful API</a></li> <li><a href="http://jwt.io/">JWT</a></li> </ul> </div> </article> <footer class="site-footer"> <div class="container"> <ul class="social"> <li><a href="http://github.com/KtorZ" target="_blank"><i class="icon icon-github"></i></a></li> <li><a href="http://linkedin.com/in/matthias-benkort-47186a57" target="_blank"><i class="icon icon-linkedin"></i></a></li> <li><a href="http://twitter.com/mbenkort" target="_blank"><i class="icon icon-twitter"></i></a></li> </ul> <p> <small>&copy;2016 All rights reserved. Made with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and ♥</small> </p> </div> </footer> </main> <script src="/assets/js/jquery-2.1.1.js"></script> <script src="/assets/js/main.js"></script> </body> </html><!-- by nandomoreira.me -->